

 Application Name     - int_sw
 Application Overview - The objective of this application is to demonstrate
                          GPIO interrupts using SW2 and SW3.
                          NOTE the switches are not debounced!





! addtogroup int_sw
! @{



 Standard includes
#include stdio.h

 Driverlib includes
#include hw_types.h
#include hw_ints.h
#include hw_memmap.h
#include hw_common_reg.h
#include interrupt.h
#include hw_apps_rcm.h
#include prcm.h
#include rom.h
#include rom_map.h
#include prcm.h
#include gpio.h
#include timer.h
#include utils.h
#include Adafruit_GFX.h
#include Adafruit_SSD1351.h
#include SPI.h
#include string.h
#include spi.h
#include uart.h
 Common interface includes
#include timer_if.h
#include gpio_if.h
#include uart_if.h
 Common interface includes
#include uart_if.h

#include pinmux.h
#define SPI_IF_BIT_RATE  100000
#define TR_BUFF_SIZE     100

#define APPLICATION_VERSION 1.1.1
#define BLACK           0x0000
#define BLUE            0x001F
#define RED             0xF800
#define GREEN           0x07E0
#define CYAN            0x07FF
#define MAGENTA         0xF81F
#define YELLOW          0xFFE0
#define WHITE 0xFFFF

                 GLOBAL VARIABLES -- Start

extern void ( const g_pfnVectors[])(void);

volatile unsigned long SW2_intcount;
volatile unsigned long SW3_intcount;
volatile unsigned char SW2_intflag;
volatile unsigned char SW3_intflag;
volatile unsigned char Code;
volatile unsigned char Edge;
static volatile unsigned long g_ulSysTickValue;
static volatile unsigned long g_ulBase;
static volatile unsigned long g_ulRefBase;
static volatile unsigned long g_ulRefTimerInts = 0;
static volatile unsigned long g_ulIntClearVector;
unsigned long g_ulTimerInts;
volatile int buf[32];
volatile int index;
volatile int score;
volatile int msgrcv;
volatile char rcv_arr[16];
volatile char tran_arr[16];
volatile int rcv_idx;
volatile int msg_length;
static unsigned char g_ucTxBuff[TR_BUFF_SIZE];
static unsigned char g_ucRxBuff[TR_BUFF_SIZE];
static unsigned char ucTxBuffNdx;
static unsigned char ucRxBuffNdx;
#define MAX_URI_SIZE 128
#define URI_SIZE MAX_URI_SIZE + 1


#define APPLICATION_NAME        SSL
#define APPLICATION_VERSION     1.1.1.EEC.Spring2018
#define SERVER_NAME             a15piclw4ix1d1-ats.iot.us-east-1.amazonaws.com
#define GOOGLE_DST_PORT         8443

#define SL_SSL_CA_CERT certrootca.der starfield class2 rootca (from firefox)  -- this one works
#define SL_SSL_PRIVATE certprivate.der
#define SL_SSL_CLIENT  certclient.der


NEED TO UPDATE THIS FOR IT TO WORK!
#define DATE                26     Current Date 
#define MONTH               1      Month 1-12 
#define YEAR                2019   Current year 
#define HOUR                10     Time - hours 
#define MINUTE              39     Time - minutes 
#define SECOND              0      Time - seconds 
#define GETHEADER  GET thingsCC3200_Thingshadow HTTP1.1nr
#define POSTHEADER POST thingsCC3200_Thingshadow HTTP1.1nr
#define HOSTHEADER Host a15piclw4ix1d1-ats.iot.us-east-1.amazonaws.comrn
#define CHEADER Connection Keep-Alivern
#define CTHEADER Content-Type applicationjson; charset=utf-8rn
#define CLHEADER1 Content-Length 
#define CLHEADER2 rnrn
#define DATA1 {state {rndesired  {rnvar  Hello phone, message from CC3200 via AWS IoT!rn}}}rnrn
#define DATA1 {state {rndesired  {rnvar  
#define DATA2 rn}}}rnrn
 Application specific statuserror codes
typedef enum{
     Choosing -0x7D0 to avoid overlap w host-driver's error codes
    LAN_CONNECTION_FAILED = -0x7D0,
    INTERNET_CONNECTION_FAILED = LAN_CONNECTION_FAILED - 1,
    DEVICE_NOT_IN_STATION_MODE = INTERNET_CONNECTION_FAILED - 1,

    STATUS_CODE_MAX = -0xBB8
}e_AppStatusCodes;

typedef struct
{
    time 
   unsigned long tm_sec;
   unsigned long tm_min;
   unsigned long tm_hour;
    date 
   unsigned long tm_day;
   unsigned long tm_mon;
   unsigned long tm_year;
   unsigned long tm_week_day; not required
   unsigned long tm_year_day; not required
   unsigned long reserved[3];
}SlDateTime;


                 GLOBAL VARIABLES -- End


 an example of how you can use structs to organize your pin settings for easier maintenance
typedef struct PinSetting {
    unsigned long port;
    unsigned int pin;
} PinSetting;

static PinSetting switch2 = { .port = GPIOA2_BASE, .pin = 0x40};
volatile unsigned long  g_ulStatus = 0;SimpleLink Status
unsigned long  g_ulPingPacketsRecv = 0; Number of Ping Packets received
unsigned long  g_ulGatewayIP = 0; Network Gateway IP address
unsigned char  g_ucConnectionSSID[SSID_LEN_MAX+1]; Connection SSID
unsigned char  g_ucConnectionBSSID[BSSID_LEN_MAX]; Connection BSSID
signed char    g_Host = SERVER_NAME;
SlDateTime g_time;
#if defined(ccs)  defined(gcc)
extern void ( const g_pfnVectors[])(void);
#endif
#if defined(ewarm)
extern uVectorEntry __vector_table;
#endif

                      LOCAL FUNCTION PROTOTYPES

static long WlanConnect();
static int set_time();
static void BoardInit(void);
static long InitializeAppVariables();
static int tls_connect();
static int connectToAccessPoint();
static int http_post(int);
static int http_get(int);

                      LOCAL FUNCTION DEFINITIONS

void
TimerBaseIntHandler(void)
{
    
     Clear the timer interrupt.
    
    Timer_IF_InterruptClear(g_ulBase);
    g_ulTimerInts ++;
}



! The interrupt handler for the second timer interrupt.
!
! param  None
!
! return none


void
TimerRefIntHandler(void)
{
    
     Clear the timer interrupt.
    
    Timer_IF_InterruptClear(g_ulRefBase);
    g_ulRefTimerInts ++;
}

UARTA1_RX interrupt
static void  RecieverIntHandler(void){
    Message(RECIEVING MESSAGErn);
    unsigned long ulStatus;
    msgrcv = 1;
    int index = 0;
    msg_length = 0;
    long character;
    while(UARTCharsAvail(UARTA1_BASE)){
        character = UARTCharGet(UARTA1_BASE);
        rcv_arr[msg_length++] = (char) character;
    }
    int i = 0;
    for (i = 0; i  msg_length; i++){
        Report(%c, rcv_arr[i]);
    }
    ulStatus = MAP_UARTIntStatus (UARTA1_BASE, true);
    MAP_UARTIntClear(UARTA1_BASE, ulStatus);
}



IR Reciever interrupt
static void BothEdgeIntHandler(void) {  SW3 handler
    Message(heren);
    unsigned long ulStatus;
    int value = MAP_GPIOPinRead(GPIOA1_BASE, 0x10);
    Report(%drn, value);
    Rising Edge
    if (value  0){
        g_ulTimerInts = 0;
        Timer_IF_Start(g_ulBase, TIMER_A, 2000);
        Edge = 1;
    }
    Falling Edge
    else{
        Report(Length %drn, g_ulTimerInts);
        if (index  32){
            if (g_ulTimerInts = 43 && g_ulTimerInts = 15){
                buf[index] = 0;
                index++;
                score = (score  1)  (0);
            }
            else if (g_ulTimerInts = 44 && g_ulTimerInts  70){
                buf[index] = 1;
                index++;
                score = (score  1)  (1);
            }
            if (index == 32){
                Edge = 1;
            }
        }
        else{
            Timer_IF_Stop(g_ulBase, TIMER_A);
        }
        if (g_ulTimerInts = 70){
            index = 0;
            score = 0;
        }
    }
    Edge = 1;
    ulStatus = MAP_GPIOIntStatus (GPIOA1_BASE, true);
    MAP_GPIOIntClear(GPIOA1_BASE, ulStatus);
}



! Board Initialization & Configuration
!
! param  None
!
! return None


void SimpleLinkWlanEventHandler(SlWlanEvent_t pWlanEvent) {
    if(!pWlanEvent) {
        return;
    }

    switch(pWlanEvent-Event) {
        case SL_WLAN_CONNECT_EVENT {
            SET_STATUS_BIT(g_ulStatus, STATUS_BIT_CONNECTION);

            
             Information about the connected AP (like name, MAC etc) will be
             available in 'slWlanConnectAsyncResponse_t'.
             Applications can use it if required
            
              slWlanConnectAsyncResponse_t pEventData = NULL;
             pEventData = &pWlanEvent-EventData.STAandP2PModeWlanConnected;
            

             Copy new connection SSID and BSSID to global parameters
            memcpy(g_ucConnectionSSID,pWlanEvent-EventData.
                   STAandP2PModeWlanConnected.ssid_name,
                   pWlanEvent-EventData.STAandP2PModeWlanConnected.ssid_len);
            memcpy(g_ucConnectionBSSID,
                   pWlanEvent-EventData.STAandP2PModeWlanConnected.bssid,
                   SL_BSSID_LENGTH);

            UART_PRINT([WLAN EVENT] STA Connected to the AP %s , 
                       BSSID %x%x%x%x%x%xnr,
                       g_ucConnectionSSID,g_ucConnectionBSSID[0],
                       g_ucConnectionBSSID[1],g_ucConnectionBSSID[2],
                       g_ucConnectionBSSID[3],g_ucConnectionBSSID[4],
                       g_ucConnectionBSSID[5]);
        }
        break;

        case SL_WLAN_DISCONNECT_EVENT {
            slWlanConnectAsyncResponse_t  pEventData = NULL;

            CLR_STATUS_BIT(g_ulStatus, STATUS_BIT_CONNECTION);
            CLR_STATUS_BIT(g_ulStatus, STATUS_BIT_IP_AQUIRED);

            pEventData = &pWlanEvent-EventData.STAandP2PModeDisconnected;

             If the user has initiated 'Disconnect' request,
            'reason_code' is SL_USER_INITIATED_DISCONNECTION
            if(SL_USER_INITIATED_DISCONNECTION == pEventData-reason_code) {
                UART_PRINT([WLAN EVENT]Device disconnected from the AP %s,
                    BSSID %x%x%x%x%x%x on application's request nr,
                           g_ucConnectionSSID,g_ucConnectionBSSID[0],
                           g_ucConnectionBSSID[1],g_ucConnectionBSSID[2],
                           g_ucConnectionBSSID[3],g_ucConnectionBSSID[4],
                           g_ucConnectionBSSID[5]);
            }
            else {
                UART_PRINT([WLAN ERROR]Device disconnected from the AP AP %s, 
                           BSSID %x%x%x%x%x%x on an ERROR..!! nr,
                           g_ucConnectionSSID,g_ucConnectionBSSID[0],
                           g_ucConnectionBSSID[1],g_ucConnectionBSSID[2],
                           g_ucConnectionBSSID[3],g_ucConnectionBSSID[4],
                           g_ucConnectionBSSID[5]);
            }
            memset(g_ucConnectionSSID,0,sizeof(g_ucConnectionSSID));
            memset(g_ucConnectionBSSID,0,sizeof(g_ucConnectionBSSID));
        }
        break;

        default {
            UART_PRINT([WLAN EVENT] Unexpected event [0x%x]nr,
                       pWlanEvent-Event);
        }
        break;
    }
}



! brief This function handles network events such as IP acquisition, IP
!           leased, IP released etc.
!
! param[in]  pNetAppEvent - Pointer to NetApp Event Info
!
! return None
!

void SimpleLinkNetAppEventHandler(SlNetAppEvent_t pNetAppEvent) {
    if(!pNetAppEvent) {
        return;
    }

    switch(pNetAppEvent-Event) {
        case SL_NETAPP_IPV4_IPACQUIRED_EVENT {
            SlIpV4AcquiredAsync_t pEventData = NULL;

            SET_STATUS_BIT(g_ulStatus, STATUS_BIT_IP_AQUIRED);

            Ip Acquired Event Data
            pEventData = &pNetAppEvent-EventData.ipAcquiredV4;

            Gateway IP address
            g_ulGatewayIP = pEventData-gateway;

            UART_PRINT([NETAPP EVENT] IP Acquired IP=%d.%d.%d.%d , 
                       Gateway=%d.%d.%d.%dnr,
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.ip,3),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.ip,2),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.ip,1),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.ip,0),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.gateway,3),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.gateway,2),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.gateway,1),
            SL_IPV4_BYTE(pNetAppEvent-EventData.ipAcquiredV4.gateway,0));
        }
        break;

        default {
            UART_PRINT([NETAPP EVENT] Unexpected event [0x%x] nr,
                       pNetAppEvent-Event);
        }
        break;
    }
}




! brief This function handles HTTP server events
!
! param[in]  pServerEvent - Contains the relevant event information
! param[in]    pServerResponse - Should be filled by the user with the
!                                      relevant response information
!
! return None
!

void SimpleLinkHttpServerCallback(SlHttpServerEvent_t pHttpEvent, SlHttpServerResponse_t pHttpResponse) {
     Unused in this application
}



! brief This function handles General Events
!
! param[in]     pDevEvent - Pointer to General Event Info
!
! return None
!

void SimpleLinkGeneralEventHandler(SlDeviceEvent_t pDevEvent) {
    if(!pDevEvent) {
        return;
    }

    
     Most of the general errors are not FATAL are are to be handled
     appropriately by the application
    
    UART_PRINT([GENERAL EVENT] - ID=[%d] Sender=[%d]nn,
               pDevEvent-EventData.deviceEvent.status,
               pDevEvent-EventData.deviceEvent.sender);
}




! This function handles socket events indication
!
! param[in]      pSock - Pointer to Socket Event Info
!
! return None
!

void SimpleLinkSockEventHandler(SlSockEvent_t pSock) {
    if(!pSock) {
        return;
    }

    switch( pSock-Event ) {
        case SL_SOCKET_TX_FAILED_EVENT
            switch( pSock-socketAsyncEvent.SockTxFailData.status) {
                case SL_ECLOSE
                    UART_PRINT([SOCK ERROR] - close socket (%d) operation 
                                failed to transmit all queued packetsnn,
                                    pSock-socketAsyncEvent.SockTxFailData.sd);
                    break;
                default
                    UART_PRINT([SOCK ERROR] - TX FAILED    socket %d , reason 
                                (%d) nn,
                                pSock-socketAsyncEvent.SockTxFailData.sd, pSock-socketAsyncEvent.SockTxFailData.status);
                  break;
            }
            break;

        default
            UART_PRINT([SOCK EVENT] - Unexpected Event [%x0x]nn,pSock-Event);
          break;
    }
}



 SimpleLink Asynchronous Event Handlers -- End breadcrumb s18_df





! brief This function initializes the application variables
!
! param    0 on success else error code
!
! return None
!

static long InitializeAppVariables() {
    g_ulStatus = 0;
    g_ulGatewayIP = 0;
    g_Host = SERVER_NAME;
    memset(g_ucConnectionSSID,0,sizeof(g_ucConnectionSSID));
    memset(g_ucConnectionBSSID,0,sizeof(g_ucConnectionBSSID));
    return SUCCESS;
}



! brief This function puts the device in its default state. It
!           - Set the mode to STATION
!           - Configures connection policy to Auto and AutoSmartConfig
!           - Deletes all the stored profiles
!           - Enables DHCP
!           - Disables Scan policy
!           - Sets Tx power to maximum
!           - Sets power policy to normal
!           - Unregister mDNS services
!           - Remove all filters
!
! param   none
! return  On success, zero is returned. On error, negative is returned

static long ConfigureSimpleLinkToDefaultState() {
    SlVersionFull   ver = {0};
    _WlanRxFilterOperationCommandBuff_t  RxFilterIdMask = {0};

    unsigned char ucVal = 1;
    unsigned char ucConfigOpt = 0;
    unsigned char ucConfigLen = 0;
    unsigned char ucPower = 0;

    long lRetVal = -1;
    long lMode = -1;

    lMode = sl_Start(0, 0, 0);
    ASSERT_ON_ERROR(lMode);

     If the device is not in station-mode, try configuring it in station-mode
    if (ROLE_STA != lMode) {
        if (ROLE_AP == lMode) {
             If the device is in AP mode, we need to wait for this event
             before doing anything
            while(!IS_IP_ACQUIRED(g_ulStatus)) {
#ifndef SL_PLATFORM_MULTI_THREADED
              _SlNonOsMainLoopTask();
#endif
            }
        }

         Switch to STA role and restart
        lRetVal = sl_WlanSetMode(ROLE_STA);
        ASSERT_ON_ERROR(lRetVal);

        lRetVal = sl_Stop(0xFF);
        ASSERT_ON_ERROR(lRetVal);

        lRetVal = sl_Start(0, 0, 0);
        ASSERT_ON_ERROR(lRetVal);

         Check if the device is in station again
        if (ROLE_STA != lRetVal) {
             We don't want to proceed if the device is not coming up in STA-mode
            return DEVICE_NOT_IN_STATION_MODE;
        }
    }

     Get the device's version-information
    ucConfigOpt = SL_DEVICE_GENERAL_VERSION;
    ucConfigLen = sizeof(ver);
    lRetVal = sl_DevGet(SL_DEVICE_GENERAL_CONFIGURATION, &ucConfigOpt,
                                &ucConfigLen, (unsigned char )(&ver));
    ASSERT_ON_ERROR(lRetVal);

    UART_PRINT(Host Driver Version %snr,SL_DRIVER_VERSION);
    UART_PRINT(Build Version %d.%d.%d.%d.31.%d.%d.%d.%d.%d.%d.%d.%dnr,
    ver.NwpVersion[0],ver.NwpVersion[1],ver.NwpVersion[2],ver.NwpVersion[3],
    ver.ChipFwAndPhyVersion.FwVersion[0],ver.ChipFwAndPhyVersion.FwVersion[1],
    ver.ChipFwAndPhyVersion.FwVersion[2],ver.ChipFwAndPhyVersion.FwVersion[3],
    ver.ChipFwAndPhyVersion.PhyVersion[0],ver.ChipFwAndPhyVersion.PhyVersion[1],
    ver.ChipFwAndPhyVersion.PhyVersion[2],ver.ChipFwAndPhyVersion.PhyVersion[3]);

     Set connection policy to Auto + SmartConfig
          (Device's default connection policy)
    lRetVal = sl_WlanPolicySet(SL_POLICY_CONNECTION,
                                SL_CONNECTION_POLICY(1, 0, 0, 0, 1), NULL, 0);
    ASSERT_ON_ERROR(lRetVal);

     Remove all profiles
    lRetVal = sl_WlanProfileDel(0xFF);
    ASSERT_ON_ERROR(lRetVal);



    
     Device in station-mode. Disconnect previous connection if any
     The function returns 0 if 'Disconnected done', negative number if already
     disconnected Wait for 'disconnection' event if 0 is returned, Ignore
     other return-codes
    
    lRetVal = sl_WlanDisconnect();
    if(0 == lRetVal) {
         Wait
        while(IS_CONNECTED(g_ulStatus)) {
#ifndef SL_PLATFORM_MULTI_THREADED
              _SlNonOsMainLoopTask();
#endif
        }
    }

     Enable DHCP client
    lRetVal = sl_NetCfgSet(SL_IPV4_STA_P2P_CL_DHCP_ENABLE,1,1,&ucVal);
    ASSERT_ON_ERROR(lRetVal);

     Disable scan
    ucConfigOpt = SL_SCAN_POLICY(0);
    lRetVal = sl_WlanPolicySet(SL_POLICY_SCAN , ucConfigOpt, NULL, 0);
    ASSERT_ON_ERROR(lRetVal);

     Set Tx power level for station mode
     Number between 0-15, as dB offset from max power - 0 will set max power
    ucPower = 0;
    lRetVal = sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID,
            WLAN_GENERAL_PARAM_OPT_STA_TX_POWER, 1, (unsigned char )&ucPower);
    ASSERT_ON_ERROR(lRetVal);

     Set PM policy to normal
    lRetVal = sl_WlanPolicySet(SL_POLICY_PM , SL_NORMAL_POLICY, NULL, 0);
    ASSERT_ON_ERROR(lRetVal);

     Unregister mDNS services
    lRetVal = sl_NetAppMDNSUnRegisterService(0, 0);
    ASSERT_ON_ERROR(lRetVal);

     Remove  all 64 filters (88)
    memset(RxFilterIdMask.FilterIdMask, 0xFF, 8);
    lRetVal = sl_WlanRxFilterSet(SL_REMOVE_RX_FILTER, (_u8 )&RxFilterIdMask,
                       sizeof(_WlanRxFilterOperationCommandBuff_t));
    ASSERT_ON_ERROR(lRetVal);

    lRetVal = sl_Stop(SL_STOP_TIMEOUT);
    ASSERT_ON_ERROR(lRetVal);

    InitializeAppVariables();

    return lRetVal;  Success
}

static void BoardInit(void) {
 In case of TI-RTOS vector table is initialize by OS itself 
#ifndef USE_TIRTOS
  
   Set vector table base
  
#if defined(ccs)
    MAP_IntVTableBaseSet((unsigned long)&g_pfnVectors[0]);
#endif
#if defined(ewarm)
    MAP_IntVTableBaseSet((unsigned long)&__vector_table);
#endif
#endif
    
     Enable Processor
    
    MAP_IntMasterEnable();
    MAP_IntEnable(FAULT_SYSTICK);

    PRCMCC3200MCUInit();
}
static long WlanConnect() {
    SlSecParams_t secParams = {0};
    long lRetVal = 0;

    secParams.Key = SECURITY_KEY;
    secParams.KeyLen = strlen(SECURITY_KEY);
    secParams.Type = SECURITY_TYPE;

    UART_PRINT(Attempting connection to access point );
    UART_PRINT(SSID_NAME);
    UART_PRINT(... ...);
    lRetVal = sl_WlanConnect(SSID_NAME, strlen(SSID_NAME), 0, &secParams, 0);
    ASSERT_ON_ERROR(lRetVal);

    UART_PRINT( Connected!!!nr);


     Wait for WLAN Event
    while((!IS_CONNECTED(g_ulStatus))  (!IS_IP_ACQUIRED(g_ulStatus))) {
         Toggle LEDs to Indicate Connection Progress
        _SlNonOsMainLoopTask();
        GPIO_IF_LedOff(MCU_IP_ALLOC_IND);
        MAP_UtilsDelay(800000);
        _SlNonOsMainLoopTask();
        GPIO_IF_LedOn(MCU_IP_ALLOC_IND);
        MAP_UtilsDelay(800000);
    }

    return SUCCESS;

}




long printErrConvenience(char  msg, long retVal) {
    UART_PRINT(msg);
    GPIO_IF_LedOn(MCU_RED_LED_GPIO);
    return retVal;
}




! This function updates the date and time of CC3200.
!
! param None
!
! return
!     0 for success, negative otherwise
!


static int set_time() {
    long retVal;

    g_time.tm_day = DATE;
    g_time.tm_mon = MONTH;
    g_time.tm_year = YEAR;
    g_time.tm_sec = HOUR;
    g_time.tm_hour = MINUTE;
    g_time.tm_min = SECOND;

    retVal = sl_DevSet(SL_DEVICE_GENERAL_CONFIGURATION,
                          SL_DEVICE_GENERAL_CONFIGURATION_DATE_TIME,
                          sizeof(SlDateTime),(unsigned char )(&g_time));

    ASSERT_ON_ERROR(retVal);
    return SUCCESS;
}



! This function demonstrates how certificate can be used with SSL.
! The procedure includes the following steps
! 1) connect to an open AP
! 2) get the server name via a DNS request
! 3) define all socket options and point to the CA certificate
! 4) connect to the server via TCP
!
! param None
!
! return  0 on success else error code
! return  LED1 is turned solid in case of success
!    LED2 is turned solid in case of failure
!

static int tls_connect() {
    SlSockAddrIn_t    Addr;
    int    iAddrSize;
    unsigned char    ucMethod = SL_SO_SEC_METHOD_TLSV1_2;
    unsigned int uiIP;
    unsigned int uiCipher = SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    unsigned int uiCipher = SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
 SL_SEC_MASK_SSL_RSA_WITH_RC4_128_SHA
 SL_SEC_MASK_SSL_RSA_WITH_RC4_128_MD5
 SL_SEC_MASK_TLS_RSA_WITH_AES_256_CBC_SHA
 SL_SEC_MASK_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
 SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
 SL_SEC_MASK_TLS_ECDHE_RSA_WITH_RC4_128_SHA
 SL_SEC_MASK_TLS_RSA_WITH_AES_128_CBC_SHA256
 SL_SEC_MASK_TLS_RSA_WITH_AES_256_CBC_SHA256
 SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
 SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256  does not work (-340, handshake fails)
    long lRetVal = -1;
    int iSockID;

    lRetVal = sl_NetAppDnsGetHostByName(g_Host, strlen((const char )g_Host),
                                    (unsigned long)&uiIP, SL_AF_INET);

    if(lRetVal  0) {
        return printErrConvenience(Device couldn't retrieve the host name nr, lRetVal);
    }

    Addr.sin_family = SL_AF_INET;
    Addr.sin_port = sl_Htons(GOOGLE_DST_PORT);
    Addr.sin_addr.s_addr = sl_Htonl(uiIP);
    iAddrSize = sizeof(SlSockAddrIn_t);
    
     opens a secure socket
    
    iSockID = sl_Socket(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);
    if( iSockID  0 ) {
        return printErrConvenience(Device unable to create secure socket nr, lRetVal);
    }

    
     configure the socket as TLS1.2
    
    lRetVal = sl_SetSockOpt(iSockID, SL_SOL_SOCKET, SL_SO_SECMETHOD, &ucMethod,
                               sizeof(ucMethod));
    if(lRetVal  0) {
        return printErrConvenience(Device couldn't set socket options nr, lRetVal);
    }
    
    configure the socket as ECDHE RSA WITH AES256 CBC SHA
    
    lRetVal = sl_SetSockOpt(iSockID, SL_SOL_SOCKET, SL_SO_SECURE_MASK, &uiCipher,
                           sizeof(uiCipher));
    if(lRetVal  0) {
        return printErrConvenience(Device couldn't set socket options nr, lRetVal);
    }




 START COMMENT THIS OUT IF DISABLING SERVER VERIFICATION
    
    configure the socket with CA certificate - for server verification
    
    lRetVal = sl_SetSockOpt(iSockID, SL_SOL_SOCKET, 
                           SL_SO_SECURE_FILES_CA_FILE_NAME, 
                           SL_SSL_CA_CERT, 
                           strlen(SL_SSL_CA_CERT));

    if(lRetVal  0) {
        return printErrConvenience(Device couldn't set socket options nr, lRetVal);
    }
 END COMMENT THIS OUT IF DISABLING SERVER VERIFICATION



    configure the socket with Client Certificate - for server verification
    
    lRetVal = sl_SetSockOpt(iSockID, SL_SOL_SOCKET, 
                SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME, 
                                    SL_SSL_CLIENT, 
                           strlen(SL_SSL_CLIENT));

    if(lRetVal  0) {
        return printErrConvenience(Device couldn't set socket options nr, lRetVal);
    }

    configure the socket with Private Key - for server verification
    
    lRetVal = sl_SetSockOpt(iSockID, SL_SOL_SOCKET, 
            SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME, 
            SL_SSL_PRIVATE, 
                           strlen(SL_SSL_PRIVATE));

    if(lRetVal  0) {
        return printErrConvenience(Device couldn't set socket options nr, lRetVal);
    }


     connect to the peer device - Google server 
    lRetVal = sl_Connect(iSockID, ( SlSockAddr_t )&Addr, iAddrSize);

    if(lRetVal = 0) {
        UART_PRINT(Device has connected to the website);
        UART_PRINT(SERVER_NAME);
        UART_PRINT(nr);
    }
    else if(lRetVal == SL_ESECSNOVERIFY) {
        UART_PRINT(Device has connected to the website (UNVERIFIED));
        UART_PRINT(SERVER_NAME);
        UART_PRINT(nr);
    }
    else if(lRetVal  0) {
        UART_PRINT(Device couldn't connect to server);
        UART_PRINT(SERVER_NAME);
        UART_PRINT(nr);
        return printErrConvenience(Device couldn't connect to server nr, lRetVal);
    }

    GPIO_IF_LedOff(MCU_RED_LED_GPIO);
    GPIO_IF_LedOn(MCU_GREEN_LED_GPIO);
    return iSockID;
}



int connectToAccessPoint() {
    long lRetVal = -1;
    GPIO_IF_LedConfigure(LED1LED3);

    GPIO_IF_LedOff(MCU_RED_LED_GPIO);
    GPIO_IF_LedOff(MCU_GREEN_LED_GPIO);

    lRetVal = InitializeAppVariables();
    ASSERT_ON_ERROR(lRetVal);

    
     Following function configure the device to default state by cleaning
     the persistent settings stored in NVMEM (viz. connection profiles &
     policies, power policy etc)
    
     Applications may choose to skip this step if the developer is sure
     that the device is in its default state at start of applicaton
    
     Note that all profiles and persistent settings that were done on the
     device will be lost
    
    lRetVal = ConfigureSimpleLinkToDefaultState();
    if(lRetVal  0) {
      if (DEVICE_NOT_IN_STATION_MODE == lRetVal)
          UART_PRINT(Failed to configure the device in its default state nr);

      return lRetVal;
    }

    UART_PRINT(Device is configured in default state nr);

    CLR_STATUS_BIT_ALL(g_ulStatus);

    
     Assumption is that the device is configured in station mode already
     and it is in its default state
    
    UART_PRINT(Opening sl_startnr);
    lRetVal = sl_Start(0, 0, 0);
    if (lRetVal  0  ROLE_STA != lRetVal) {
        UART_PRINT(Failed to start the device nr);
        return lRetVal;
    }

    UART_PRINT(Device started as STATION nr);

    
    Connecting to WLAN AP
    
    lRetVal = WlanConnect();
    if(lRetVal  0) {
        UART_PRINT(Failed to establish connection w an AP nr);
        GPIO_IF_LedOn(MCU_RED_LED_GPIO);
        return lRetVal;
    }

    UART_PRINT(Connection established w AP and IP is aquired nr);
    return 0;
}



! Main function
!
! param none
!
!
! return None.


 int main() {
    unsigned long ulStatus;

    long lRetVal = -1;
    
     Initialize board configuration
    
    BoardInit();

    PinMuxConfig();

    InitTerm();
    ClearTerm();
    UART_PRINT(My terminal works!nr);

    Connect the CC3200 to the local access point
    lRetVal = connectToAccessPoint();
    Set time so that encryption can be used
    lRetVal = set_time();
    if(lRetVal  0) {
        UART_PRINT(Unable to set time in the device);
        LOOP_FOREVER();
    }
    Connect to the website with TLS encryption
    lRetVal = tls_connect();
    if(lRetVal  0) {
        ERR_PRINT(lRetVal);
    }
    MAP_UARTConfigSetExpClk(UARTA1_BASE,MAP_PRCMPeripheralClockGet(PRCM_UARTA1),
                     115200, (UART_CONFIG_WLEN_8  UART_CONFIG_STOP_ONE 
                      UART_CONFIG_PAR_NONE));




    MAP_GPIOIntRegister(GPIOA1_BASE, BothEdgeIntHandler);
    MAP_GPIOIntTypeSet(GPIOA1_BASE, 0x10, GPIO_BOTH_EDGES);     IR GPIO
    MAP_UARTIntRegister(UARTA1_BASE, RecieverIntHandler);

    ulStatus = MAP_GPIOIntStatus (GPIOA2_BASE, false);
    MAP_GPIOIntClear(GPIOA2_BASE, ulStatus);
    ulStatus = MAP_UARTIntStatus (UARTA1_BASE, false);
    MAP_UARTIntClear(UARTA1_BASE, ulStatus);
    ulStatus = MAP_GPIOIntStatus (GPIOA1_BASE, false);
    MAP_GPIOIntClear(GPIOA1_BASE, ulStatus);  clear interrupts on GPIOA1
    ulStatus = MAP_GPIOIntStatus (switch2.port, false);

    MAP_GPIOIntClear(switch2.port, ulStatus);            clear interrupts on GPIOA2
    SPI Initialization
    MAP_PRCMPeripheralClkEnable(PRCM_GSPI,PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralReset(PRCM_GSPI);
    MAP_SPIReset(GSPI_BASE);
    MAP_SPIConfigSetExpClk(GSPI_BASE,MAP_PRCMPeripheralClockGet(PRCM_GSPI),
                         SPI_IF_BIT_RATE,SPI_MODE_MASTER,SPI_SUB_MODE_0,
                         (SPI_SW_CTRL_CS 
                         SPI_4PIN_MODE 
                         SPI_TURBO_OFF 
                         SPI_CS_ACTIVEHIGH 
                         SPI_WL_8));

    MAP_SPIEnable(GSPI_BASE);
     clear global variables
    SW2_intcount=0;
    SW3_intcount=0;
    SW2_intflag=0;
    SW3_intflag=0;
    Edge = 0; flag of IR_int_handler
    Code = 0;
    index = 0; index of IR buffer
    score = 0; 32-bit interger value of buffer
    msgrcv = 0; if we have recieved a msg
    rcv_idx = 0; char index for the recieving character buffer
    msg_length = 0; length of recieving message
    Enable Interrupts
    MAP_GPIOIntEnable(GPIOA1_BASE, 0x10);
    MAP_UARTIntEnable(UARTA1_BASE, UART_INT_RX);
    UARTTxIntModeSet(UARTA1_BASE,  UART_TXINT_MODE_EOT);
    UARTFIFOEnable(UARTA1_BASE);
    UARTFIFOLevelSet(UARTA1_BASE,UART_FIFO_TX6_8,  UART_FIFO_RX6_8);
    
     Base address for first timer
    
    g_ulBase = TIMERA0_BASE;
    
     Base address for second timer
    
    g_ulRefBase = TIMERA1_BASE;
    
     Configuring the timers
    
    Timer_IF_Init(PRCM_TIMERA0, g_ulBase, TIMER_CFG_PERIODIC, TIMER_A, 0);
    Timer_IF_Init(PRCM_TIMERA1, g_ulRefBase, TIMER_CFG_PERIODIC, TIMER_A, 0);

    
     Setup the interrupts for the timer timeouts.
    
    Timer_IF_IntSetup(g_ulBase, TIMER_A, TimerBaseIntHandler);
    Timer_IF_IntSetup(g_ulRefBase, TIMER_A, TimerRefIntHandler);

    
     Turn on the timers feeding values in mSec
    
    Timer_IF_Start(g_ulBase, TIMER_A, 2000);
    Timer_IF_Start(g_ulRefBase, TIMER_A, 1000);

    GPIOPinWrite(GPIOA2_BASE, 0x40, 0x40);

    Adafruit_Init();
    fillScreen(RED);
    MAP_UARTIntEnable(UARTA1_BASE, UART_INT_RX);
    int rcvtxt = 0;
    long character;
    int current = -1;
    int previous = -1;
    int tran_idx = 0;
    char cr = 'a';
    int key_press = -1;
    int old_key = -1;
    int replace = 0;
    int size = 0; where we are on transmit array same as size
    char current = 0;
    int dup = 0; Number of times we have cycled through the digit
    int i = 0;

    while (1) {
        while (Edge == 0 && msgrcv == 0) {;}
        Report(Timer %drn, g_ulRefTimerInts);
        if (Edge){
            Message(g_ulBase %dn, g_ulBase);
            
            for (i = 0; i  32; i++){
                Report(%d, buf[i]);
            }
            Message(rn);
            
            Report(  Score %d, score);
            switch (score){
            case 79370471 Message(0rn); current = ' '; key_press = 0; break;
            case 79396991 Message(1rn); current = ; break;
            case 79380671 Message(2rn); current = 'a'; key_press = 2; break;
            case 79413311 Message(3rn); current = 'd'; key_press = 3; break;
            case 79405151 Message(4rn); current = 'g'; key_press = 4; break;
            case 79388831 Message(5rn); current = 'j'; key_press = 5; break;
            case 79421471 Message(6rn); current = 'm'; key_press = 6; break;
            case 79401071 Message(7rn); current = 'p'; key_press = 7; break;
            case 79384751 Message(8rn); current = 't'; key_press = 8; break;
            case 79417391 Message(9rn); current = 'w'; key_press = 9; break;
            case 79373021 Message(MUTErn); current = 0; key_press = 10; break; ENTER
            case 79401581 Message(LASTrn); current = 0; key_press = 11; break; DELETE
            default Message(KEY NOT FOUND rn); current = -1; key_press = -1; break;
            }
            if (key_press  -1)  valid key press
            {
                Report(%crn, current);
                
            if (key_press == 10 && size){ SEND
                Report(size %drn, size);
                send message (index size)
                delete old message on screen
                int j = 0;

                for (j = 0; j  size; j++){
                    Report(j %drn, j);
                    Report(tran_arr[%d] %crn,j, tran_arr[j]);
                    MAP_UARTCharPut(UARTA1_BASE, tran_arr[j]);
                }
                for (j = size - 1; j = 10; j++){
                    MAP_UARTCharPut(UARTA1_BASE, ' ');
                }
                drawRect(0, 0, 128, 16, BLACK);
                fillRect(0, 0, 128, 16, BLACK);
                set cursor back to starting position
                http_post(lRetVal, size);
                size = 0;

            }
            else if (key_press == 0){ SPACE
                add a space to the char array
                Probably just put a rectangle
                drawRect(10size, 0, 10, 20, BLACK);
                tran_arr[size++] = ' ';
                drawChar(size10, 0, ' ', GREEN, BLACK, 2);
                move index over one position
            }
            else if (key_press == 11 && size){ BACKSPACEDELETE
                If there are characters to delete
                delete element from char array
                size--;
                drawRect(10size, 0, 128, 16, BLACK);
                fillRect(10size, 0, 128, 16, BLACK);
                drawRect(10size, 0, 10, 20, BLACK);
                move index to the left
            }
            else if (g_ulRefTimerInts  60000 && (key_press == old_key) && size){ If duplicate
                need to change letter being displayed
                alter in display
                alter in character array
                no change in size

                current = tran_arr[(size - 1)];
                if (key_press == 7  key_press == 9){  4 options
                    if (dup == 3){ wrap around
                        current = current - 3;
                        dup = 0;
                    }
                    else{
                        current++;
                        dup++;
                    }
                }
                else{  3 options
                    if (dup == 2){ wrap around
                        current = current - 2;
                        dup = 0;
                    }
                    else{
                        current++;
                        dup++;
                    }
                }
                insert
                drawChar((size-1)10, 0, current, GREEN, BLACK, 2);
                tran_arr[(size - 1)] = current;
                replace = 1;
            }
            else if (key_press != 10 && key_press != 11){ Regular operation
                if (g_ulRefTimerInts = 60000 && replace){
                    size++;
                    drawChar((size)10, 0, current, GREEN, BLACK, 2);
                    replace = 0;

                }
                else{
                    drawChar(size10, 0, current, GREEN, BLACK, 2);
                }
                add character to array
                add character to display
                Move cursor to next line
                We are using 16 characters
                So one line would be 12816 = 8 pixels per character
                Could do two lines with 16 pixels, we will see
                tran_arr[size++] = current;
                old_key = key_press;
                dup = 0;
            }
            set key_press to previous so we can check if duplicate
            restart timer counter

            if (current == 10){
                Message(Send messagern);
                cr = previous + 'a';
                Report(%crn, cr);
                MAP_UARTCharPut(UARTA1_BASE, cr);
            }
            
            g_ulRefTimerInts = 0;
            old_key = key_press;
            previous = current;
            }
            Edge = 0;
            index = 0;
            score = 0;

        }
        if (msgrcv){
            drawRect(0, 60, 128, 16, BLACK);
            fillRect(0, 60, 128, 16, BLACK);
            int i;
            for (i = 0; i  msg_length; i++){
                drawChar(i10, 60, rcv_arr[i], GREEN, BLACK, 2);
                rcvtxt++;
            }
            msgrcv = 0;
            msg_length = 0;
        }

    }
}







 Close the Doxygen group.
! @}


 static int http_post(int iTLSSockID, int size){
     char acSendBuff[512];
     char acRecvbuff[1460];
     char cCLLength[200];
     char pcBufHeaders;
     int lRetVal = 0;
#define DATA1 {state {rndesired  {rnvar  Hello phone, message from CC3200 via AWS IoT!rn}}}rnrn
     pcBufHeaders = acSendBuff;
     strcpy(pcBufHeaders, POSTHEADER);
     pcBufHeaders += strlen(POSTHEADER);
     strcpy(pcBufHeaders, HOSTHEADER);
     pcBufHeaders += strlen(HOSTHEADER);
     strcpy(pcBufHeaders, CHEADER);
     pcBufHeaders += strlen(CHEADER);
     strcpy(pcBufHeaders, rnrn);

     int dataLength = strlen(DATA1);

     strcpy(pcBufHeaders, CTHEADER);
     pcBufHeaders += strlen(CTHEADER);
     strcpy(pcBufHeaders, CLHEADER1);

     pcBufHeaders += strlen(CLHEADER1);
     sprintf(cCLLength, %d, dataLength);

     strcpy(pcBufHeaders, cCLLength);
     pcBufHeaders += strlen(cCLLength);
     strcpy(pcBufHeaders, CLHEADER2);
     pcBufHeaders += strlen(CLHEADER2);

     strcpy(pcBufHeaders, DATA1);
     pcBufHeaders += strlen(DATA1);
     for (int i = 0; i  size; i++){
         (pcBufHeaders) = tran_arr[i];
         pcBufHeaders++;
     }


     strcpy(pcBufHeaders, DATA2);
     pcBufHeaders += strlen(DATA2);

     int testDataLength = strlen(pcBufHeaders);

     UART_PRINT(acSendBuff);


     
      Send the packet to the server 
     
     lRetVal = sl_Send(iTLSSockID, acSendBuff, strlen(acSendBuff), 0);
     if(lRetVal  0) {
         UART_PRINT(POST failed. Error Number %inr,lRetVal);
         sl_Close(iTLSSockID);
         GPIO_IF_LedOn(MCU_RED_LED_GPIO);
         return lRetVal;
     }
     lRetVal = sl_Recv(iTLSSockID, &acRecvbuff[0], sizeof(acRecvbuff), 0);
     if(lRetVal  0) {
         UART_PRINT(Received failed. Error Number %inr,lRetVal);
         sl_Close(iSSLSockID);
         GPIO_IF_LedOn(MCU_RED_LED_GPIO);
            return lRetVal;
     }
     else {
         acRecvbuff[lRetVal+1] = '0';
         UART_PRINT(acRecvbuff);
         UART_PRINT(nrnr);
     }

     return 0;
 }
